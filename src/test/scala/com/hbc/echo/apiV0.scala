package com.hbc.echo

/**
  * Generated by API Builder - https://www.apibuilder.io
  * Service version: 0.2.2
  * apibuilder:0.12.52 https://app.apibuilder.io/hbc/echo-api/0.2.2/http4s_0_15
  */
package com.hbc.echo.api.v0.models {

  /**
    * The echo
    *
    * @param message Something to be echoed....
    */
  case class Echo(
                   message: String
                 )

}

package com.hbc.echo.api.v0.models {

  package object json {
    import io.circe.syntax._
    import io.circe.{Decoder, Encoder, Json}

    import scala.util.Try

    // Make Scala 2.11 Either monadic
    private[v0] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[v0] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[v0] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](_.toString)

    private[v0] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.Instant.parse(str)))

    private[v0] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[v0] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[v0] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit def decodeEchoApiEcho: Decoder[Echo] = Decoder.instance { c =>
      for {
        message <- c.downField("message").as[String]
      } yield {
        Echo(
          message = message
        )
      }
    }

    implicit def encodeEchoApiEcho: Encoder[Echo] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("message" -> t.message.asJson)
      ).flatten)
    }
  }
}

package com.hbc.echo.api.v0 {
  import org.http4s.client.blaze._

  object Constants {

    val BaseUrl = "http://live.echo-api-master.stqa.s5a.hbccommon.private.hbc.com"
    val Namespace = "com.hbc.echo.api.v0"
    val UserAgent = "apibuilder:0.12.52 https://app.apibuilder.io/hbc/echo-api/0.2.2/http4s_0_15"
    val Version = "0.2.2"
    val VersionMajor = 0

  }

  class Client(
                val baseUrl: org.http4s.Uri = org.http4s.Uri.unsafeFromString("http://live.echo-api-master.stqa.s5a.hbccommon.private.hbc.com"),
                auth: scala.Option[com.hbc.echo.api.v0.Authorization] = None,
                defaultHeaders: Seq[(String, String)] = Nil,
                asyncHttpClient: org.http4s.client.Client = Client.defaultAsyncHttpClient
              ) extends interfaces.Client {
    import org.http4s.Response
    implicit def circeJsonDecoder[A](implicit decoder: io.circe.Decoder[A]) = org.http4s.circe.jsonOf[A]
    implicit def circeJsonEncoder[A](implicit encoder: io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[A]
    import com.hbc.echo.api.v0.models.json._

    import scalaz._
    import scalaz.concurrent.Task

    def closeAsyncHttpClient() {
      asyncHttpClient.shutdownNow()
    }

    def echoes: Echoes = Echoes

    object Echoes extends Echoes {
      override def get(
                        message: String,
                        requestHeaders: Seq[(String, String)] = Nil
                      ): scalaz.concurrent.Task[_root_.scala.Option[com.hbc.echo.api.v0.models.Echo]] = {
        val urlPath = Seq("echo", message)

        _executeRequest[Unit, _root_.scala.Option[com.hbc.echo.api.v0.models.Echo]]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 =>
            com.hbc.echo.api.v0.Client.parseJson[_root_.scala.Option[com.hbc.echo.api.v0.models.Echo]]("com.hbc.echo.api.v0.models.Echo", r)
          case r if r.status.code == 400 => Task.fail(com.hbc.echo.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 500 => Task.fail(com.hbc.echo.api.v0.errors.UnitResponse(r.status.code))
          case r => Task.fail(com.hbc.echo.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 400, 404, 500"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: Task[org.http4s.Request]): Task[org.http4s.Request] = request

    def _executeRequest[T, U](
                               method: String,
                               path: Seq[String],
                               queryParameters: Seq[(String, String)] = Nil,
                               requestHeaders: Seq[(String, String)] = Nil,
                               body: Option[T] = None
                             )(handler: Response => Task[U]
                             )(implicit encoder: org.http4s.EntityEncoder[T]): Task[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case \/-(m) => m
        case -\/(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
          defaultHeaders ++
          requestHeaders
        ).toList.map { case (k, v) => org.http4s.Header(k, v) })

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request(method = m,
        uri = uri,
        headers = headers)

      val authReq = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header("Authorization", s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val authBody = body.fold(Task.now(authReq))(authReq.withBody)

      asyncHttpClient.fetch(modifyRequest(authBody))(handler)
    }
  }

  object Client {
    import scalaz._
    import scalaz.concurrent.Task


    private lazy val defaultAsyncHttpClient = PooledHttp1Client()

    def parseJson[T](
                      className: String,
                      r: org.http4s.Response
                    )(implicit decoder: org.http4s.EntityDecoder[T]): Task[T] = r.attemptAs[T].run.flatMap {
      case \/-(value) => Task.now(value)
      case -\/(error) => Task.fail(new com.hbc.echo.api.v0.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client {
      def baseUrl: org.http4s.Uri
      def echoes: com.hbc.echo.api.v0.Echoes
    }

  }

  trait Echoes {
    /**
      * Echo a message
      *
      * @param message the message to be echoed
      */
    def get(
             message: String,
             requestHeaders: Seq[(String, String)] = Nil
           ): scalaz.concurrent.Task[_root_.scala.Option[com.hbc.echo.api.v0.models.Echo]]
  }

  package errors {

    case class UnitResponse(status: Int) extends Exception(s"HTTP $status")

    case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}